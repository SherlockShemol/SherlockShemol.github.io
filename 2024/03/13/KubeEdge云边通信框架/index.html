<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>KubeEdge云边通信框架 · Shemol's Blog</title><meta name="description" content="参考资料
KubeEdge云原生边缘计算公开课15-KubeEdge工程目录导读及云边通信框架源码 
kubeedge源码分析系列（二）：cloudhub

BeehiveBeehive是KubeEdge中的核心消息通讯框架，用于不同模块的注册和模块之间的通信，KubeEdge中的CloudCore"><meta name="og:description" content="参考资料
KubeEdge云原生边缘计算公开课15-KubeEdge工程目录导读及云边通信框架源码 
kubeedge源码分析系列（二）：cloudhub

BeehiveBeehive是KubeEdge中的核心消息通讯框架，用于不同模块的注册和模块之间的通信，KubeEdge中的CloudCore"><meta name="twitter:site" content="Shemol's Blog"><meta name="twitter:title" content="KubeEdge云边通信框架"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">Shemol's Blog</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/"></a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li><a href="/about/index.html">about</a></li><li><a href="/friends/index.html">friends</a></li><li class="soc"></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="https://shemol.tech" rel="noopener noreferrer">Shemol</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>KubeEdge云边通信框架</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2024-03-13</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/KubeEdge/" title="KubeEdge">KubeEdge</a><span>&nbsp;</span></span></p><p class="post-abstract"><span id="more"></span>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Cs4y1Y7Fh/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=fb3c060e45699897f1aaf5bd6a5a30e7">KubeEdge云原生边缘计算公开课15-KubeEdge工程目录导读及云边通信框架源码</a> </li>
<li><a target="_blank" rel="noopener" href="http://www.sel.zju.edu.cn/blog/2020/12/21/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%BA%8Ccloudhub/">kubeedge源码分析系列（二）：cloudhub</a></li>
</ul>
<h1 id="Beehive"><a href="#Beehive" class="headerlink" title="Beehive"></a>Beehive</h1><p>Beehive是KubeEdge中的核心消息通讯框架，用于不同模块的注册和模块之间的通信，KubeEdge中的CloudCore和EdgeCore组件都依赖于beehive框架。因此，我们需要首先了解Beehive的工作机制，才能更进一步理解KubeEdge的设计理念和工作原理。<br>Beehive是基于goland channel实现的消息通信框架，核心能力包含两部分：module注册管理和module间通信管理，分别对应beehive中定义的接口ModuleContext和MessageContext，其架构图如下所示：<br><img src="/img/kubeedge-1.png"></p>
<h2 id="message通信格式"><a href="#message通信格式" class="headerlink" title="message通信格式"></a>message通信格式</h2><p>在分析beehive的具体功能之前，我们先看一下通信的消息格式，message是beehive中不同module之间通信的信息载体，message包含三部分内容，如下所示：</p>
<ul>
<li>Header：<ul>
<li>ID：消息ID，UUID字符串</li>
<li>ParentID：如果是对同步消息的响应，则说明parentID存在 (只会在同步消息的响应中存在)</li>
<li>TimeStamp：生成消息的时间 （时间戳</li>
<li>Sync：消息是否为同步类型消息的标志，为<code>true</code>则说明是同步消息</li>
</ul>
</li>
<li>Route：<ul>
<li>Source：消息的来源</li>
<li>Group：消息所属的group</li>
<li>Operation：资源的操作</li>
<li>Resource：操作的资源</li>
</ul>
</li>
<li>Content：消息的内容</li>
</ul>
<h2 id="context数据结构"><a href="#context数据结构" class="headerlink" title="context数据结构"></a>context数据结构</h2><p>ModuleContext和MessageContext定义的接口均由Context来实现，其数据结构如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment">//Context is object for Context channel</span><br><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span>&#123;<br>	<span class="hljs-comment">//ConfigFactory goarchaius.ConfigurationFactory</span><br>	channels <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">chan</span> model.Message<br>	chsLock  sync.RwMutex<br>	typeChannels <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">chan</span> model.Message<br>	typeChsLock  sync.RWMutex<br>	anonChannels <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword"><code class="language-hljs go"><span class="hljs-comment">//Context is object for Context channel</span><br><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span>&#123;<br>	<span class="hljs-comment">//ConfigFactory goarchaius.ConfigurationFactory</span><br>	channels <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">chan</span> model.Message<br>	chsLock  sync.RwMutex<br>	typeChannels <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">chan</span> model.Message<br>	typeChsLock  sync.RWMutex<br>	anonChannels <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">chan</span> model.Message<br>	anonChsLock  sync.RWMutex<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p>完整代码链接：<a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/beehive/pkg/core/channel/context_channel.go">https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/beehive/pkg/core/channel/context_channel.go</a></p>
<ul>
<li>channels - channels是模块的名称和对应的消息channel映射，用于将消息发送到相应的模块</li>
<li>chsLock - channels map的锁</li>
<li>typeChannels - typeChannels是一个两级map，第一级key是group名字，第二级key是module名字，value是module对应的消息channel。</li>
<li>typeChsLock - typeChannels map的锁</li>
<li>annoChannels - annoChannels是消息parentID到channel的映射，将用于发送同步消息的响应。</li>
<li>annoChsLock - annoChannels map的锁</li>
</ul>
<h2 id="beehive-module管理"><a href="#beehive-module管理" class="headerlink" title="beehive module管理"></a>beehive module管理</h2><p>在beehive中，module定义是一个接口，只要实现了此接口，便可以称为module，在KubeEdge中常见的模块，如cloudhub、edgehub、edgeController等，都已经实现了这个接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment">//Module Interface </span><br><span class="hljs-keyword">type</span> Moudule <span class="hljs-keyword">interface</span>&#123;<br>	Name() <span class="hljs-type">string</span><br>	Group() <span class="hljs-type">string</span><br>	Start() <br>	Enable() <span class="hljs-type"><code class="language-hljs go"><span class="hljs-comment">//Module Interface </span><br><span class="hljs-keyword">type</span> Moudule <span class="hljs-keyword">interface</span>&#123;<br>	Name() <span class="hljs-type">string</span><br>	Group() <span class="hljs-type">string</span><br>	Start() <br>	Enable() <span class="hljs-type">bool</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p>完整代码：<a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/beehive/pkg/core/module.go">https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/beehive/pkg/core/module.go</a></p>
<p>Beehive支持的module操作如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go">	<span class="hljs-keyword">type</span> ModuleContext <span class="hljs-keyword">interface</span> &#123;<br>	AddModule(info *common.ModuleInfo)<br>	AddModuleGroup(module.group <span class="hljs-type">string</span>)<br>	Cleanup(module <span class="hljs-type"><code class="language-hljs go">	<span class="hljs-keyword">type</span> ModuleContext <span class="hljs-keyword">interface</span> &#123;<br>	AddModule(info *common.ModuleInfo)<br>	AddModuleGroup(module.group <span class="hljs-type">string</span>)<br>	Cleanup(module <span class="hljs-type">string</span>)<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p>完整代码：<a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/beehive/pkg/core/context/context.go">https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/beehive/pkg/core/context/context.go</a></p>
<table>
<thead>
<tr>
<th>接口</th>
<th>功能</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>AddModule</td>
<td>添加module</td>
<td>首先创建一个message类型的channel，然后保存到Context中的channels map里</td>
</tr>
<tr>
<td>AddModuleGroup</td>
<td>添加module到所属group</td>
<td>首先会从Context中的channels map里查询对应的channel，然后将对应的group以及module和channel保存到typeChannels里面</td>
</tr>
<tr>
<td>Cleanup</td>
<td>清理module</td>
<td>将module信息从channels和typeChannels清除</td>
</tr>
</tbody></table>
<h2 id="beehive消息通信管理"><a href="#beehive消息通信管理" class="headerlink" title="beehive消息通信管理"></a>beehive消息通信管理</h2><p>beehive中注册的模块之间，可以相互通信，beehive支持多种通信方式，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment">//MessageContext is interface for messaging syncing</span><br><span class="hljs-keyword">type</span> MessageContext <span class="hljs-keyword">interface</span> &#123;<br>	<span class="hljs-comment">//async mode</span><br>	Send(module <span class="hljs-type">string</span>, message model.Message)<br>	Receive(module <span class="hljs-type">string</span>)(model.Message <span class="hljs-type">error</span>)<br>	<span class="hljs-comment">//sync mode</span><br>	SendSync(module <span class="hljs-type">string</span>,message model.Message,timeout time.Duration)(model.Message <span class="hljs-type">error</span>)<br>	SendResp(message model.Message)<br>	<span class="hljs-comment">//group broadcast</span><br>	SendToGroup(group <span class="hljs-type">string</span>,message model.Message)<br>	SendToGroupSync(group <span class="hljs-type">string</span>,message model.Message,timeout time.Duration) <span class="hljs-type"><code class="language-hljs go"><span class="hljs-comment">//MessageContext is interface for messaging syncing</span><br><span class="hljs-keyword">type</span> MessageContext <span class="hljs-keyword">interface</span> &#123;<br>	<span class="hljs-comment">//async mode</span><br>	Send(module <span class="hljs-type">string</span>, message model.Message)<br>	Receive(module <span class="hljs-type">string</span>)(model.Message <span class="hljs-type">error</span>)<br>	<span class="hljs-comment">//sync mode</span><br>	SendSync(module <span class="hljs-type">string</span>,message model.Message,timeout time.Duration)(model.Message <span class="hljs-type">error</span>)<br>	SendResp(message model.Message)<br>	<span class="hljs-comment">//group broadcast</span><br>	SendToGroup(group <span class="hljs-type">string</span>,message model.Message)<br>	SendToGroupSync(group <span class="hljs-type">string</span>,message model.Message,timeout time.Duration) <span class="hljs-type">error</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/beehive/pkg/core/context/context.go">https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/beehive/pkg/core/context/context.go</a></p>
<table>
<thead>
<tr>
<th>接口</th>
<th>功能</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>Send</td>
<td>发送异步消息到指定module</td>
<td>从Context中的channels map里查询对应module的channel，然后将消息放入到channel里面</td>
</tr>
<tr>
<td>Receive</td>
<td>接收发送到指定module的消息</td>
<td>从Context中的Channels map查询对应module的channel，然后从channel里面取出消息，如果没有消息到达，则会阻塞，直至有消息到达</td>
</tr>
<tr>
<td>SendSync</td>
<td>发送同步消息到指定module</td>
<td>SendSync从channels map中获取模块的channel，将消息放入channel，然后创建一个新的channel，并将其添加到annoChannels映射中，其中key是messageID，然后在这个channel上等待接收消息（响应），直到超时，如果在超时之前收到响应消息，则返回响应消息，否则返回空的消息和超时错误</td>
</tr>
<tr>
<td>SendResp</td>
<td>发送对同步消息的响应</td>
<td>根据message中parentID在annoChannels查找对应的channel，然后将消息放入channel中，如果不存在，则记录错误</td>
</tr>
<tr>
<td>SendToGroup</td>
<td>发送异步消息到指定group下的所有module</td>
<td>SendToGroup从typeChannels map中获取指定group下的所有module，然后遍历module，依次发送消息到module</td>
</tr>
<tr>
<td>SendToGroupSync</td>
<td>发送同步消息到指定group下的所有module</td>
<td>SendToGroup从typeChannels map中获取指定group下的所有module，创建了一个size和module数量一样的匿名通道，然后遍历module，调用send发送消息，然后等待匿名消息通道收到消息的数量等于size</td>
</tr>
</tbody></table>
<h2 id="beehive模块注册启动"><a href="#beehive模块注册启动" class="headerlink" title="beehive模块注册启动"></a>beehive模块注册启动</h2><p>在cloudcore或者edgecore启动的时候，会将所有的module注册到beehive内核，beehive中维护了module名字到module的映射。</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment">//registerModules register all the modules started in cloudcore</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">registerModules</span><span class="hljs-params"><code class="language-hljs go"><span class="hljs-comment">//registerModules register all the modules started in cloudcore</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">registerModules</span><span class="hljs-params">(c *v1alpha1.CloudCoreConfig)</span></span>&#123;<br>	cloudhub.Register(c.Modules.Cloudhub)<br>	edgecontroller.Register(c.Modules.EdgeController)<br>	devicecontroller.Register(c.Modules.DeviceController)<br>	nodeupgradejobcontroller.Register(c.Modules.NodeUpgradeJobController)<br>	synccontroller.Register(c.Modules.SyncController)<br>	cloudstream.Register(c.Modules.CloudStream,c.CommonConfig)<br>	router.Register(c.Modules.Router)<br>	dynamiccontroller.Register(c.Modules.DynamicController)<br>	policycontroller.Register(client.CrdConfig)<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/blob/master/cloud/cmd/cloudcore/app/server.go#L155-L166">https://github.com/kubeedge/kubeedge/blob/master/cloud/cmd/cloudcore/app/server.go#L155-L166</a><br>在beehive启动的时候，会获取所有注册的module，然后遍历所有的module，依次执行如下操作：</p>
<ol>
<li>根据module的类型，初始化moduleInfo信息</li>
<li>执行beehiveContext.AddModule</li>
<li>执行beehiveContext.AddModuleGroup</li>
<li>调用每个module的start方法启动module<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment">//StartModules starts modules that are registered </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StartModules</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">//only register channel mode,if want to use socket mode,we should also pass in common.MsgCtxTypeUSparameter</span><br>	beehiveContext.InitContext([]<span class="hljs-type">string</span>&#123;common.MsgCtxTypeChannel&#125;)<br><br>	modules := GetModules()<br><br>	<span class="hljs-keyword">for</span> name, module := <span class="hljs-keyword">range</span> modules&#123;<br>		<span class="hljs-keyword">var</span> m common.ModuleInfo<br>		<span class="hljs-keyword">switch</span> module.contextType&#123;<br>		<span class="hljs-keyword">case</span> common.MsgCtxTypeChannel:<br>			m = common.ModuleInfo&#123;<br>				ModuleName: name,<br>				ModuleType: module.contextType,<br>			&#125;<br>		......<br><br>		<span class="hljs-keyword">default</span>:<br>			klog.Exitf(<span class="hljs-string">&quot;unsupported context type: %s&quot;</span>,module.contextType)<br>		&#125;<br><br>		beehiveContext.AddModule(&amp;m)<br>		beehiveContext.AddModuleGroup(name,module.module.Group())<br><br>		<span class="hljs-keyword">go</span> moduleKeeper(name, module, m)<br>		klog.Infof(<span class="hljs-string"><code class="language-hljs go"><span class="hljs-comment">//StartModules starts modules that are registered </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StartModules</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">//only register channel mode,if want to use socket mode,we should also pass in common.MsgCtxTypeUSparameter</span><br>	beehiveContext.InitContext([]<span class="hljs-type">string</span>&#123;common.MsgCtxTypeChannel&#125;)<br><br>	modules := GetModules()<br><br>	<span class="hljs-keyword">for</span> name, module := <span class="hljs-keyword">range</span> modules&#123;<br>		<span class="hljs-keyword">var</span> m common.ModuleInfo<br>		<span class="hljs-keyword">switch</span> module.contextType&#123;<br>		<span class="hljs-keyword">case</span> common.MsgCtxTypeChannel:<br>			m = common.ModuleInfo&#123;<br>				ModuleName: name,<br>				ModuleType: module.contextType,<br>			&#125;<br>		......<br><br>		<span class="hljs-keyword">default</span>:<br>			klog.Exitf(<span class="hljs-string">&quot;unsupported context type: %s&quot;</span>,module.contextType)<br>		&#125;<br><br>		beehiveContext.AddModule(&amp;m)<br>		beehiveContext.AddModuleGroup(name,module.module.Group())<br><br>		<span class="hljs-keyword">go</span> moduleKeeper(name, module, m)<br>		klog.Infof(<span class="hljs-string">"starting module %s"</span>,name)<br>	&#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/beehive/pkg/core/core.go">https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/beehive/pkg/core/core.go</a></li>
</ol>
<h1 id="viaduct"><a href="#viaduct" class="headerlink" title="viaduct"></a>viaduct</h1><p>viaduct是KubeEdge云边通信的中间件，基于统一的抽象接口，提供了不同协议的服务端和客户端实现，用于边缘节点和云端管理面的连接管理和数据传输管理。viaduct屏蔽了不同网络协议之间的差异，使用统一的接口对上层提供服务，支持用户可以通过配置云边通信的网络协议灵活选择接入协议。目前内置了多种网络协议的实现。如websocket和quic。后续根据不同的边缘接入场景和业务场景，<strong>通过viaduct可以快速对接新的网络协议，满足用户的需求</strong>。<br>viaduct中主要分为两部分：服务端和客户端接口以及不同协议的实现。服务端被云端组件CloudCore所使用，用来启动不同协议的server，用来边缘节点的接入和数据传输，客户端被边缘组件edgeCore所使用，是用来发起接入的client，用于连接云端CloudCore组件。其主要架构如下图所示：<br><img src="/img/kubeedge-2.png"><br>接下来以WebSocket协议为例子，来介绍服务端和客户端接口以及实现。</p>
<h2 id="Connection接口定义"><a href="#Connection接口定义" class="headerlink" title="Connection接口定义"></a>Connection接口定义</h2><p>Connection是viaduct中核心的接口，viaduct支持双向通信协议，云端和边缘节点可以双向消息传输，在边缘节点接入的时候，server端和client端均需要初始化Connection，并通过此Connection进行全双工通信。Connection接口定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment">//the operation set of connection</span><br><span class="hljs-keyword">type</span> Connection <span class="hljs-keyword">interface</span>&#123;<br>	<span class="hljs-comment">//process message from the connection</span><br>	ServeConn() <span class="hljs-comment">//服务端从通道中持续的读取消息</span><br><br>	<span class="hljs-comment">//SetReadDeadline sets the deadline for future Read calls</span><br>	<span class="hljs-comment">//and any currently-blocked Read call.</span><br>	<span class="hljs-comment">//A zero value for t means Read will not time out.</span><br>	SetReadDeadline(t time.Time) <span class="hljs-type">error</span><br><br>	<span class="hljs-comment">//SetWriteDeadline sets the deadline for future write calls</span><br>	<span class="hljs-comment">//and any currently-blocked write call.</span><br>	<span class="hljs-comment">//Even if write times out.It may return n &gt; 0, indicating that </span><br>	<span class="hljs-comment">//some of the data was successfully written.</span><br>	<span class="hljs-comment">//A zero value for t means write will not time out.</span><br>	SetWriteDeadline(t time.Time) <span class="hljs-type">error</span><br><br>	<span class="hljs-comment">//write write raw data to the connection </span><br>	<span class="hljs-comment">//it will open a stream for raw data </span><br>	write(raw []<span class="hljs-type">byte</span>)(<span class="hljs-type">int</span>,<span class="hljs-type">error</span>)<br><br>	<span class="hljs-comment">//writeMessageAsync writes data to the connection and don&#x27;t care about the response </span><br>	WriteMessageAsync(msg *model.Message) <span class="hljs-type">error</span> <span class="hljs-comment">//异步</span><br><br>	<span class="hljs-comment">//writeMessageSync writes data to the connection and care about the response</span><br>	WriteMessageSync(msg *model.Message)(*model.Message,<span class="hljs-type">error</span>) <span class="hljs-comment">//同步</span><br><br>	<span class="hljs-comment">//ReadMessage reads message from the connection</span><br>	<span class="hljs-comment">//it will be blocked when no message received </span><br>	<span class="hljs-comment">//if you want to use this api for message reading</span><br>	<span class="hljs-comment">//make sure AutoRoute be false </span><br>	ReadMessage(msg *model.Message ) <span class="hljs-type">error</span><br><br>	<span class="hljs-comment">//RemoteAddr returns the remote network address</span><br>	RemoteAddr() net.Addr<br><br>	<span class="hljs-comment">//LocalAddr returns the local network address</span><br>	LocalAddr() net.Addr<br><br>	<span class="hljs-comment">//connectState return the current connection state</span><br>	ConnectionState() connectionState<br><br>	<span class="hljs-comment">//Close closes the connection</span><br>	<span class="hljs-comment">//Any blocked Read or Write operations will be unblocked and return errors</span><br>	Close() <span class="hljs-type"><code class="language-hljs go"><span class="hljs-comment">//the operation set of connection</span><br><span class="hljs-keyword">type</span> Connection <span class="hljs-keyword">interface</span>&#123;<br>	<span class="hljs-comment">//process message from the connection</span><br>	ServeConn() <span class="hljs-comment">//服务端从通道中持续的读取消息</span><br><br>	<span class="hljs-comment">//SetReadDeadline sets the deadline for future Read calls</span><br>	<span class="hljs-comment">//and any currently-blocked Read call.</span><br>	<span class="hljs-comment">//A zero value for t means Read will not time out.</span><br>	SetReadDeadline(t time.Time) <span class="hljs-type">error</span><br><br>	<span class="hljs-comment">//SetWriteDeadline sets the deadline for future write calls</span><br>	<span class="hljs-comment">//and any currently-blocked write call.</span><br>	<span class="hljs-comment">//Even if write times out.It may return n &gt; 0, indicating that </span><br>	<span class="hljs-comment">//some of the data was successfully written.</span><br>	<span class="hljs-comment">//A zero value for t means write will not time out.</span><br>	SetWriteDeadline(t time.Time) <span class="hljs-type">error</span><br><br>	<span class="hljs-comment">//write write raw data to the connection </span><br>	<span class="hljs-comment">//it will open a stream for raw data </span><br>	write(raw []<span class="hljs-type">byte</span>)(<span class="hljs-type">int</span>,<span class="hljs-type">error</span>)<br><br>	<span class="hljs-comment">//writeMessageAsync writes data to the connection and don&#x27;t care about the response </span><br>	WriteMessageAsync(msg *model.Message) <span class="hljs-type">error</span> <span class="hljs-comment">//异步</span><br><br>	<span class="hljs-comment">//writeMessageSync writes data to the connection and care about the response</span><br>	WriteMessageSync(msg *model.Message)(*model.Message,<span class="hljs-type">error</span>) <span class="hljs-comment">//同步</span><br><br>	<span class="hljs-comment">//ReadMessage reads message from the connection</span><br>	<span class="hljs-comment">//it will be blocked when no message received </span><br>	<span class="hljs-comment">//if you want to use this api for message reading</span><br>	<span class="hljs-comment">//make sure AutoRoute be false </span><br>	ReadMessage(msg *model.Message ) <span class="hljs-type">error</span><br><br>	<span class="hljs-comment">//RemoteAddr returns the remote network address</span><br>	RemoteAddr() net.Addr<br><br>	<span class="hljs-comment">//LocalAddr returns the local network address</span><br>	LocalAddr() net.Addr<br><br>	<span class="hljs-comment">//connectState return the current connection state</span><br>	ConnectionState() connectionState<br><br>	<span class="hljs-comment">//Close closes the connection</span><br>	<span class="hljs-comment">//Any blocked Read or Write operations will be unblocked and return errors</span><br>	Close() <span class="hljs-type">error</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/viaduct/pkg/conn/conn.go">https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/viaduct/pkg/conn/conn.go</a></p>
<p>其核心接口如下：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ServeConn</td>
<td>云端server使用，持续的从connection中读取数据并转换成message，然后调用回调函数执行分发操作</td>
</tr>
<tr>
<td>Read</td>
<td>从connection中读取原始byte数据</td>
</tr>
<tr>
<td>Write</td>
<td>向connection中写入原始byte数据</td>
</tr>
<tr>
<td>WriteMessageAsync</td>
<td>向connection中写入message数据，不需要对端响应</td>
</tr>
<tr>
<td>WriteMessageSync</td>
<td>向connection中写入message数据，同时等待对端的响应消息</td>
</tr>
<tr>
<td>ReadMessage</td>
<td>从connection中读取数据并转化为message格式</td>
</tr>
</tbody></table>
<h2 id="server接口定义及websocket实现"><a href="#server接口定义及websocket实现" class="headerlink" title="server接口定义及websocket实现"></a>server接口定义及websocket实现</h2><p>server的接口定义比较简单</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment">//protocol server </span><br><span class="hljs-keyword">type</span> ProtocolServer <span class="hljs-keyword">interface</span> &#123;<br>	ListenAndServerTLS() <span class="hljs-type">error</span><br>	<span class="hljs-built_in">close</span>() <span class="hljs-type"><code class="language-hljs go"><span class="hljs-comment">//protocol server </span><br><span class="hljs-keyword">type</span> ProtocolServer <span class="hljs-keyword">interface</span> &#123;<br>	ListenAndServerTLS() <span class="hljs-type">error</span><br>	<span class="hljs-built_in">close</span>() <span class="hljs-type">error</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p>websocket协议的实现也比较简单</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *WSServer)</span></span> ListenAndServeTLS() <span class="hljs-type">error</span>&#123;<br>		<span class="hljs-keyword">return</span> srv.server.ListenAndServeTLS(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *WSServer)</span></span>Close() <span class="hljs-type">error</span>&#123;<br>	<span class="hljs-keyword">if</span> srv.server != <span class="hljs-literal">nil</span>&#123;<br>		<span class="hljs-keyword">return</span> srv.server.Close()<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal"><code class="language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *WSServer)</span></span> ListenAndServeTLS() <span class="hljs-type">error</span>&#123;<br>		<span class="hljs-keyword">return</span> srv.server.ListenAndServeTLS(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *WSServer)</span></span>Close() <span class="hljs-type">error</span>&#123;<br>	<span class="hljs-keyword">if</span> srv.server != <span class="hljs-literal">nil</span>&#123;<br>		<span class="hljs-keyword">return</span> srv.server.Close()<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/viaduct/pkg/server/ws.go">https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/viaduct/pkg/server/ws.go</a><br>WSServer的核心逻辑在于ServeHTTP方法里面，用于处理边缘节点的接入，流程如下所示：<br><img src="/img/kubeedge-3.png"></p>
<h2 id="client接口定义及websocket实现"><a href="#client接口定义及websocket实现" class="headerlink" title="client接口定义及websocket实现"></a>client接口定义及websocket实现</h2><p>client接口定义也是比较简单，如下所示，Connect方法用于连接云端的server，并返回Connection对象，然后边缘侧使用此connection进行消息的读取和写入</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment">//each protocol(websocket/quic) provides Connect</span><br><span class="hljs-keyword">type</span> Protocolclient <span class="hljs-keyword">interface</span>&#123;<br>	Connect() (conn.Connection,<span class="hljs-type"><code class="language-hljs go"><span class="hljs-comment">//each protocol(websocket/quic) provides Connect</span><br><span class="hljs-keyword">type</span> Protocolclient <span class="hljs-keyword">interface</span>&#123;<br>	Connect() (conn.Connection,<span class="hljs-type">error</span>)<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p>websocket Client通过dial发起对云端的连接，连接成功之后，如果对应的Callback不为空，则发起回调函数，然后初始化connection对象并返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment">//Connect try to connect remote server</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *WSClient)</span></span>Connect()(conn.Connection,<span class="hljs-type">error</span>)&#123;<br>	header := c.exOpts.Header<br>	header.Add(<span class="hljs-string">&quot;ConnectionUse&quot;</span>,<span class="hljs-type">string</span>(c.options.ConnUse))<br>	wsConn,resp,err := c.dialer.Dial(c.options.Addr,header)<br>	<span class="hljs-keyword">if</span> err ==<span class="hljs-literal">nil</span>&#123;<br>		klog.Infof(<span class="hljs-string">&quot;dial %s successfully&quot;</span>,c.options.Addr)<br><br>		<span class="hljs-comment">//do user&#x27;s processing on connection or response</span><br>		<span class="hljs-keyword">if</span> c.exOpts.callback != <span class="hljs-literal">nil</span>&#123;<br>			c.exOpts.Callback(wsConn,resp)<br>		&#125;<br>		<span class="hljs-keyword">return</span> conn.NewConnection(&amp;conn.ConnectionOptions&#123;<br>			ConnType: api.ProtocolTypeWS,<br>			ConnUse:  c.options.ConnUse,<br>			Base:     wsConn,<br>			Consumer: c.options.Consumer,<br>			Handler:  c.options.Handler,<br>			CtrlLane: lane.NewLane(api.ProtocolTypeWS,wsConn),<br>			State:    &amp;conn.ConnectionState&#123;<br>				State:  api.StatConnected,<br>				Headers:c.exOpts.Header.Clone(),<br>			&#125;,<br>			AutoRoute: c.options.AutoRoute,<br>		&#125;),<span class="hljs-literal">nil</span><br>	&#125;<br><br>	<span class="hljs-comment">//something wrong!</span><br>	<span class="hljs-keyword">var</span> respMsg <span class="hljs-type">string</span><br>	<span class="hljs-keyword">if</span> resp != <span class="hljs-literal">nil</span>&#123;<br>		body, errRead := io.ReadAll(io.LimitReader(resp.Body,comm.MaxReadLength))<br>		<span class="hljs-keyword">if</span> errRead ==<span class="hljs-literal">nil</span>&#123;<br>			respMsg = fmt.Sprintf(<span class="hljs-string">&quot;response code: %d,response body: %s&quot;</span>,resp.StatusCode,<span class="hljs-type">string</span>(body))<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			respMsg = fmt.Sprintf(<span class="hljs-string">&quot;response code: %d&quot;</span>,resp.StatusCode)<br>		&#125;<br>		resp.Body.Close()<br>	&#125;<br>	klog.Errorf(<span class="hljs-string">&quot;dial websocket error(%+v), response message: %s&quot;</span>,err, respMsg)<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal"><code class="language-hljs go"><span class="hljs-comment">//Connect try to connect remote server</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *WSClient)</span></span>Connect()(conn.Connection,<span class="hljs-type">error</span>)&#123;<br>	header := c.exOpts.Header<br>	header.Add(<span class="hljs-string">&quot;ConnectionUse&quot;</span>,<span class="hljs-type">string</span>(c.options.ConnUse))<br>	wsConn,resp,err := c.dialer.Dial(c.options.Addr,header)<br>	<span class="hljs-keyword">if</span> err ==<span class="hljs-literal">nil</span>&#123;<br>		klog.Infof(<span class="hljs-string">&quot;dial %s successfully&quot;</span>,c.options.Addr)<br><br>		<span class="hljs-comment">//do user&#x27;s processing on connection or response</span><br>		<span class="hljs-keyword">if</span> c.exOpts.callback != <span class="hljs-literal">nil</span>&#123;<br>			c.exOpts.Callback(wsConn,resp)<br>		&#125;<br>		<span class="hljs-keyword">return</span> conn.NewConnection(&amp;conn.ConnectionOptions&#123;<br>			ConnType: api.ProtocolTypeWS,<br>			ConnUse:  c.options.ConnUse,<br>			Base:     wsConn,<br>			Consumer: c.options.Consumer,<br>			Handler:  c.options.Handler,<br>			CtrlLane: lane.NewLane(api.ProtocolTypeWS,wsConn),<br>			State:    &amp;conn.ConnectionState&#123;<br>				State:  api.StatConnected,<br>				Headers:c.exOpts.Header.Clone(),<br>			&#125;,<br>			AutoRoute: c.options.AutoRoute,<br>		&#125;),<span class="hljs-literal">nil</span><br>	&#125;<br><br>	<span class="hljs-comment">//something wrong!</span><br>	<span class="hljs-keyword">var</span> respMsg <span class="hljs-type">string</span><br>	<span class="hljs-keyword">if</span> resp != <span class="hljs-literal">nil</span>&#123;<br>		body, errRead := io.ReadAll(io.LimitReader(resp.Body,comm.MaxReadLength))<br>		<span class="hljs-keyword">if</span> errRead ==<span class="hljs-literal">nil</span>&#123;<br>			respMsg = fmt.Sprintf(<span class="hljs-string">&quot;response code: %d,response body: %s&quot;</span>,resp.StatusCode,<span class="hljs-type">string</span>(body))<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			respMsg = fmt.Sprintf(<span class="hljs-string">&quot;response code: %d&quot;</span>,resp.StatusCode)<br>		&#125;<br>		resp.Body.Close()<br>	&#125;<br>	klog.Errorf(<span class="hljs-string">&quot;dial websocket error(%+v), response message: %s&quot;</span>,err, respMsg)<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>,err<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/viaduct/pkg/client/ws.go">https://github.com/kubeedge/kubeedge/blob/master/staging/src/github.com/kubeedge/viaduct/pkg/client/ws.go</a></p>
<h1 id="cloudhub"><a href="#cloudhub" class="headerlink" title="cloudhub"></a>cloudhub</h1><p>Cloudhub是云端组件Cloudcore的一个模块，负责边缘节点的接入和云边数据传输，是Controllers和边缘Edgecore之间的中介，它负责分发下行消息（其内封装了k8s资源事件，如pod update等）到边缘节点，也负责接收边缘节点发送的状态消息并转发至对应的controllers。Cloudhub在KubeEdge中的位置如下所示：<br><img src="/img/kubeedge-4.png"><br>Cloudhub内部有几个重要的代码模块，如下所示：<br><img src="/img/kubeedge-5.png"></p>
<ul>
<li>HTTP server：为边缘节点提供证书服务入口，如获取CA证书、证书签发与证书轮转</li>
<li>WebSocket server：可配置是否开启，为边缘节点提供WebSocket协议接入服务</li>
<li>QUIC server：可配置是否开启，为边缘节点提供QUIC协议接入服务</li>
<li>CSI socket server：在云端用来和csi driver通信</li>
<li>Token manager：边缘节点接入token凭据管理，token默认12h轮转</li>
<li>Certificate manager：边缘节点证书签发和轮转的实现模块</li>
<li>message handler：边缘节点接入管理和边缘消息处理分发</li>
<li>node session manager：边缘节点会话生命周期管理</li>
<li>message dispatcher：上行和下行消息分发管理</li>
</ul>
<h2 id="Cloudhub启动流程"><a href="#Cloudhub启动流程" class="headerlink" title="Cloudhub启动流程"></a>Cloudhub启动流程</h2><p>Cloudhub在Cloudcore启动时注册，通过beehive消息通信框架调用Start()函数启动Cloudhub模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre class="line-numbers language-hljs plaintext"><code class="language-hljs plaintext">cloudhub.Register(c.modules.Cloudhub)<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p>Cloudhub启动的时候，首先会启动dispatcher.DispatchDownstream协程，用来异步分发下行消息，其次进行证书的初始化，如果没有配置证书，则会自动生成CA和服务证书，用于后续WebSocket、Quic、HTTP服务的安全通讯。然后启动token manager模块，生成边缘节点接入使用的token凭据以及开启自动轮转服务。StartHTTPServer()启动服务器监听，主要用于EdgeCore申请证书，它将等待edgecore发来请求，获取证书。然后，启动cloudhub服务，具体的操作是使用viaduct中间件启动一个服务器，等待edgecore发来连接的请求，协议可以是基于tcp的WebSocket或基于udp的QUIC。如果用户需要使用CSI相关功能，则会启动CSI socket server。</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ch *cloudHub)</span></span> Start()&#123;<br>	<span class="hljs-keyword">if</span> !cache.WaitForCacheSync(beehiveContext.Done(),ch.informersSyncedFuncs...<br>	&#123;<br>		klog.Errorf(<span class="hljs-string">&quot;unable to sync caches for objectSyncController&quot;</span>)<br>		os.Exit(<span class="hljs-number">1</span>)<br>	&#125;<br><br>	<span class="hljs-comment">//start dispatch message from the cloud to edge node</span><br>	<span class="hljs-keyword">go</span> ch.dispatcher.DispatchDownstream()<br><br>	<span class="hljs-comment">//check whether the certificates exists in the local directory.</span><br>	<span class="hljs-comment">//and then check whether certificates exists in the secret.</span><br>	<span class="hljs-comment">//generate if they don&#x27;t exist</span><br>	<span class="hljs-keyword">if</span> err := httpserver.PrepareAllCerts(): err!=<span class="hljs-literal">nil</span>&#123;<br>		klog.Exit(err)<br>	&#125;<br><br>	DoneTLSTunnelCerts &lt;- <span class="hljs-literal">true</span><br>	<span class="hljs-built_in">close</span>(DoneTLSTunnelCerts)<br><br>	<span class="hljs-comment">//generate Token</span><br>	<span class="hljs-keyword">if</span> err:=httpserver.GenerateToken():err!=<span class="hljs-literal">nil</span>&#123;<br>		klog.Exit(err)<br>	&#125;<br><br>	<span class="hljs-comment">//HttpServer mainly used to issue certificates for the edge</span><br>	<span class="hljs-keyword">go</span> httpserver.StartHTTPServer()<br><br>	servers.StartCloudHub(ch.messageHandler)<br><br>	<span class="hljs-keyword">if</span> hubconfig.Config.UnixSocket.Enable&#123;<br>	<span class="hljs-comment">//The uds server is only used to communicate with csi driver from kubeedge on cloud</span><br>	<span class="hljs-comment">//It is not used to communicate  between cloud and edge</span><br>	<span class="hljs-keyword"><code class="language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ch *cloudHub)</span></span> Start()&#123;<br>	<span class="hljs-keyword">if</span> !cache.WaitForCacheSync(beehiveContext.Done(),ch.informersSyncedFuncs...<br>	&#123;<br>		klog.Errorf(<span class="hljs-string">&quot;unable to sync caches for objectSyncController&quot;</span>)<br>		os.Exit(<span class="hljs-number">1</span>)<br>	&#125;<br><br>	<span class="hljs-comment">//start dispatch message from the cloud to edge node</span><br>	<span class="hljs-keyword">go</span> ch.dispatcher.DispatchDownstream()<br><br>	<span class="hljs-comment">//check whether the certificates exists in the local directory.</span><br>	<span class="hljs-comment">//and then check whether certificates exists in the secret.</span><br>	<span class="hljs-comment">//generate if they don&#x27;t exist</span><br>	<span class="hljs-keyword">if</span> err := httpserver.PrepareAllCerts(): err!=<span class="hljs-literal">nil</span>&#123;<br>		klog.Exit(err)<br>	&#125;<br><br>	DoneTLSTunnelCerts &lt;- <span class="hljs-literal">true</span><br>	<span class="hljs-built_in">close</span>(DoneTLSTunnelCerts)<br><br>	<span class="hljs-comment">//generate Token</span><br>	<span class="hljs-keyword">if</span> err:=httpserver.GenerateToken():err!=<span class="hljs-literal">nil</span>&#123;<br>		klog.Exit(err)<br>	&#125;<br><br>	<span class="hljs-comment">//HttpServer mainly used to issue certificates for the edge</span><br>	<span class="hljs-keyword">go</span> httpserver.StartHTTPServer()<br><br>	servers.StartCloudHub(ch.messageHandler)<br><br>	<span class="hljs-keyword">if</span> hubconfig.Config.UnixSocket.Enable&#123;<br>	<span class="hljs-comment">//The uds server is only used to communicate with csi driver from kubeedge on cloud</span><br>	<span class="hljs-comment">//It is not used to communicate  between cloud and edge</span><br>	<span class="hljs-keyword">go</span> udsserver.StartServer(hubconfig.Config.unixSocket.Address)<br>	&#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/blob/master/cloud/pkg/cloudhub/cloudhub.go">https://github.com/kubeedge/kubeedge/blob/master/cloud/pkg/cloudhub/cloudhub.go</a><br>接下来，我们看一下cloudhub的核心功能，边缘节点接入管理和消息分发管理，下图是CloudHub的内部实现架构图：<br><img src="/img/kubeedge-6.png"></p>
<h2 id="下行消息发送模式"><a href="#下行消息发送模式" class="headerlink" title="下行消息发送模式"></a>下行消息发送模式</h2><p>发送到边缘节点的下行消息，有两种发送模式，这两种发送模式，直接关系到下行消息的分发和节点session的消息处理，如下所示：</p>
<blockquote>
<p>ACK模式：在这种模式下，边缘节点收到下行消息并将消息正确保存到本地数据存储之后，需要给云端发送ACK响应消息以通知云端消息在边缘侧被正确处理，如果云端没有收到ACK消息，则认为消息没有在边缘节点正确处理，则会重试，直到收到ACK响应消息</p>
<p>NO-ACK模式：在这种模式下，边缘节点收到下行消息后，不需要给云端发送ACK响应消息，云端认为边缘侧已经收到消息并正确处理，在这种模式下，消息有可能丢失。这种模式，通常用于给边缘节点同步消息发送响应，如果边缘侧没有收到响应，则会触发重试操作。</p>
</blockquote>
<h2 id="边缘节点接入"><a href="#边缘节点接入" class="headerlink" title="边缘节点接入"></a>边缘节点接入</h2><p>边缘节点接入的主要逻辑在messageHandler里面，handler接口如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span>&#123;<br>	<span class="hljs-comment">//HandleConnection is invoked when a new connection arrives</span><br>	HandleConnection(connection conn.Connection)<br><br>	<span class="hljs-comment">//HandleMessage is invoked when a new message arrives</span><br>	HandleMessage(container *mux.MessageContainer,writer mux.ResponseWriter)<br><br>	<span class="hljs-comment">//OnEdgeNodeConnect is invoked when a new connection is established</span><br>	OnEdgeNodeConnect(info *model.HubInfo,connection conn.Connection) <span class="hljs-type">error</span><br>	<span class="hljs-comment">//OnEdgeNodeDisconnect is invoked when a connection is lost</span><br>	OnEdgeNodeDisconnect(info *model.HubInfo,connection conn.Connection)<br><br>	<span class="hljs-comment"><code class="language-hljs go"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span>&#123;<br>	<span class="hljs-comment">//HandleConnection is invoked when a new connection arrives</span><br>	HandleConnection(connection conn.Connection)<br><br>	<span class="hljs-comment">//HandleMessage is invoked when a new message arrives</span><br>	HandleMessage(container *mux.MessageContainer,writer mux.ResponseWriter)<br><br>	<span class="hljs-comment">//OnEdgeNodeConnect is invoked when a new connection is established</span><br>	OnEdgeNodeConnect(info *model.HubInfo,connection conn.Connection) <span class="hljs-type">error</span><br>	<span class="hljs-comment">//OnEdgeNodeDisconnect is invoked when a connection is lost</span><br>	OnEdgeNodeDisconnect(info *model.HubInfo,connection conn.Connection)<br><br>	<span class="hljs-comment">//OnReadTransportErr is invoked when the connection read message err</span><br>	<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/blob/master/cloud/pkg/cloudhub/handler/message_handler.go">https://github.com/kubeedge/kubeedge/blob/master/cloud/pkg/cloudhub/handler/message_handler.go</a><br>HandleConnection用来处理边缘节点接入，以WebSocket协议接入为例，WebSocket server通过viaduct启动之后，当有边缘节点接上来时，viaduct中serverHTTP将http协议upgrade成为websocket协议，然后初始化Connection对象，HandleConnection根据传入的connection对象进行一系列初始化操作：</p>
<ol>
<li>执行初始化前的校验工作，如是否超过配置的node数量限制。<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go">nodeID := connection.ConnectionState().Headers.Get(<span class="hljs-string">&quot;node_id&quot;</span>)<br>projectID := connection.ConnectionState().Headers.Get(<span class="hljs-string">&quot;project_id&quot;</span>)<br><br><span class="hljs-keyword">if</span> mh.SessionManager.ReachLimit()&#123;<br>	klog.Errorf(<span class="hljs-string">&quot;Fail to serve node %s,reach node limit&quot;</span>,nodeID)<br>	<span class="hljs-keyword"><code class="language-hljs go">nodeID := connection.ConnectionState().Headers.Get(<span class="hljs-string">&quot;node_id&quot;</span>)<br>projectID := connection.ConnectionState().Headers.Get(<span class="hljs-string">&quot;project_id&quot;</span>)<br><br><span class="hljs-keyword">if</span> mh.SessionManager.ReachLimit()&#123;<br>	klog.Errorf(<span class="hljs-string">&quot;Fail to serve node %s,reach node limit&quot;</span>,nodeID)<br>	<span class="hljs-keyword">return</span> <br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure></li>
<li>初始化nodeMessagePool，并加入到MessageDispatcher的哈希表中，用于存储分发的下行消息。<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment"><code class="language-hljs go"><span class="hljs-comment">//init node message pool and add to the dispatcher</span><br>nodeMessagePool := common.InitNodeMessagePool(nodeID)<br>mh.MessageDispatcher.AddNodeMessagePool(nodeID,nodeMessagePool)<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
nodeMessagePool是用来存储下行消息的队列，每个边缘节点在接入时，都会初始化一个对应的nodeMessagePool，和之前的下行消息发送模式对应，nodeMessagePool包含两个队列，分别用来存储ACK和NO-ACK模式的下行消息。<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment">//NodeMessagePool is a collection of all downstream message sent to an</span><br><span class="hljs-comment">//edge node.There are two types of messages,one that requires an ack </span><br><span class="hljs-comment">//and another that does not.For each type of message.we use the &#x27;queue&#x27; </span><br><span class="hljs-comment">//to mark the order of sending, and use the &#x27;store&#x27; to store specific messages</span><br><span class="hljs-keyword">type</span> NodeMessagePool <span class="hljs-keyword">struct</span>&#123;<br>	<span class="hljs-comment">//AckMessageStore store message that will send to edge node </span><br>	<span class="hljs-comment">//and require acknowledgement from edge node</span><br>	AckMessageStore cache.Store<br>	<span class="hljs-comment">//AckMessageQueue store message key that will send to edge node</span><br>	<span class="hljs-comment">//and require acknowledgement from edge node </span><br>	AckMessageQueue workqueue.RateLimitingInterface<br>	<span class="hljs-comment">//NoAckMessageStore store message that will send to edge node</span><br>	<span class="hljs-comment">//and do not require acknowledgement from edge node</span><br>	NoAckMessageStore cache.Store<br>	<span class="hljs-comment">//NoAckMessageQueue store message key that will send to edge node</span><br>	<span class="hljs-comment"><code class="language-hljs go"><span class="hljs-comment">//NodeMessagePool is a collection of all downstream message sent to an</span><br><span class="hljs-comment">//edge node.There are two types of messages,one that requires an ack </span><br><span class="hljs-comment">//and another that does not.For each type of message.we use the &#x27;queue&#x27; </span><br><span class="hljs-comment">//to mark the order of sending, and use the &#x27;store&#x27; to store specific messages</span><br><span class="hljs-keyword">type</span> NodeMessagePool <span class="hljs-keyword">struct</span>&#123;<br>	<span class="hljs-comment">//AckMessageStore store message that will send to edge node </span><br>	<span class="hljs-comment">//and require acknowledgement from edge node</span><br>	AckMessageStore cache.Store<br>	<span class="hljs-comment">//AckMessageQueue store message key that will send to edge node</span><br>	<span class="hljs-comment">//and require acknowledgement from edge node </span><br>	AckMessageQueue workqueue.RateLimitingInterface<br>	<span class="hljs-comment">//NoAckMessageStore store message that will send to edge node</span><br>	<span class="hljs-comment">//and do not require acknowledgement from edge node</span><br>	NoAckMessageStore cache.Store<br>	<span class="hljs-comment">//NoAckMessageQueue store message key that will send to edge node</span><br>	<span class="hljs-comment">//and do not require acknowledgement from edge node</span><br>	NoAckMessageQueue workqueue.RateLimitingInterface<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/blob/master/cloud/pkg/cloudhub/common/message_pool.go">https://github.com/kubeedge/kubeedge/blob/master/cloud/pkg/cloudhub/common/message_pool.go</a></li>
<li>初始化nodeSession对象，加入到SessionManager哈希表中，并启动nodeSession<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment">//create a node session for each edge node </span><br>nodeSession := session.NewNodeSession(nodeID,projectID,connection,<br>	keepaliveInterval,nodeMessagePool,mh.reliableClient)<br><span class="hljs-comment">//add node session  to the session manager</span><br>mh.SessionManager.AddSession(nodeSession)<br><br><span class="hljs-comment">//Start session for each edge node and it will keep running until </span><br><span class="hljs-comment"><code class="language-hljs go"><span class="hljs-comment">//create a node session for each edge node </span><br>nodeSession := session.NewNodeSession(nodeID,projectID,connection,<br>	keepaliveInterval,nodeMessagePool,mh.reliableClient)<br><span class="hljs-comment">//add node session  to the session manager</span><br>mh.SessionManager.AddSession(nodeSession)<br><br><span class="hljs-comment">//Start session for each edge node and it will keep running until </span><br><span class="hljs-comment">//it encounters some Transport Error from underlying connection.</span><br>nodeSession.Start()<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
每个边缘节点对应一个nodeSession，nodeSession是对每个边缘节点连接会话的抽象，SessionManager存储并管理连接到当前cloudHub的所有边缘节点的session，nodeSession启动时，会启动该节点所需要的所有处理协程，包括：KeepAliveCheck心跳检测，SendAckMessage发送ACK模式的下行消息，SendNoAckMessage发送NO-ACK模式的下行消息。<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment">//Start the main goroutine responsible for serving node session</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ns *NodeSession)</span></span>Start()&#123;<br>	klog.Infof(<span class="hljs-string">&quot;Start session for edge node %s&quot;</span>,ns.nodeID)<br><br>	<span class="hljs-keyword">go</span> ns.KeepAliveCheck()<br>	<span class="hljs-keyword">go</span> ns.SendAckMessage()<br>	<span class="hljs-keyword"><code class="language-hljs go"><span class="hljs-comment">//Start the main goroutine responsible for serving node session</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ns *NodeSession)</span></span>Start()&#123;<br>	klog.Infof(<span class="hljs-string">&quot;Start session for edge node %s&quot;</span>,ns.nodeID)<br><br>	<span class="hljs-keyword">go</span> ns.KeepAliveCheck()<br>	<span class="hljs-keyword">go</span> ns.SendAckMessage()<br>	<span class="hljs-keyword">go</span> ns.SendNoAckMessage()<br><br>	<-ns.ctx.Done()<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="上下行消息分发"><a href="#上下行消息分发" class="headerlink" title="上下行消息分发"></a>上下行消息分发</h2><p>在CloudHub中，上下行消息的处理比较简单，主要逻辑在messageHandler的HandleMessage方法中，底层的viaduct库进行数据的解析转换成MessageContainer对象，里面包含了message信息，HandleMessage收到message后，进行简单的校验，然后调用MessageDispatcher DispatchUpstream方法，转发到不同的模块，如edgeController、deviceController等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-comment">//HandleMessage handle all the request from node </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mh *messageHandler)</span></span>HandleMessage(coantainer *mux.MessageContainer,writer mux.ResponseWriter)&#123;<br>	nodeID := container.Header.Get(<span class="hljs-string">&quot;node_id&quot;</span>)<br>	projectID := container.Header.Get(<span class="hljs-string">&quot;project_id&quot;</span>)<br><br>	<span class="hljs-comment">//validate message</span><br>	<span class="hljs-keyword">if</span> container.Message == <span class="hljs-literal">nil</span>&#123;<br>		klog.Errorf(<span class="hljs-string">&quot;The message is nil for node: %s&quot;</span>,nodeID)<br>		<span class="hljs-keyword">return</span> <br>	&#125;<br><br>	klog.v(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">&quot;[messageHandler]get msg from node(%s): %+v&quot;</span>,nodeID,container.Message)<br><br>	<span class="hljs-comment"><code class="language-hljs go"><span class="hljs-comment">//HandleMessage handle all the request from node </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mh *messageHandler)</span></span>HandleMessage(coantainer *mux.MessageContainer,writer mux.ResponseWriter)&#123;<br>	nodeID := container.Header.Get(<span class="hljs-string">&quot;node_id&quot;</span>)<br>	projectID := container.Header.Get(<span class="hljs-string">&quot;project_id&quot;</span>)<br><br>	<span class="hljs-comment">//validate message</span><br>	<span class="hljs-keyword">if</span> container.Message == <span class="hljs-literal">nil</span>&#123;<br>		klog.Errorf(<span class="hljs-string">&quot;The message is nil for node: %s&quot;</span>,nodeID)<br>		<span class="hljs-keyword">return</span> <br>	&#125;<br><br>	klog.v(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">&quot;[messageHandler]get msg from node(%s): %+v&quot;</span>,nodeID,container.Message)<br><br>	<span class="hljs-comment">//dispatch upstream message </span><br>	mh.MessageDispatcher.DispatchUpstream(container.Message,&model.HubInfo&#123;ProjectID: projectID,NodeID:nodeID&#125;)<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p>下行消息的分发流程，以发送ACK消息为例，主要包括以下流程：</p>
<ol>
<li>KubeEdge使用K8s objectSync CRD存储已成功发送到Edge的资源的最新的resourceVersion。当Cloudhub重新启动或正常启动时，它将检查待发送的资源resourceVersion和已发送成功的resourceVersion，以避免发送旧消息。</li>
<li>EdgeController和devicecontroller等将消息发送到Cloudhub，MessageDispatcher将根据消息中的节点名称，将消息发送到对应的NodeMessagePool，同时会根据消息的resource等信息来选择发送模式。在加入队列的过程中，会查询资源对应的objectSync CR，获取发送成功的最新资源resourceVersion，并和待加入队列的消息比较，避免重复发送。</li>
<li>节点对应的nodeSession SendAckMessage协程将顺序地将数据从NodeMessagePool取出发送到相应的边缘节点，同时并将消息ID存储在ACK channel中。当收到来自边缘节点的ACK消息时，ACK channel将收到通知，并将当前消息的resourceVersion保存到objectSync CR中，并发送下一条消息。</li>
<li>当Edgecore收到消息时，它将首先将消息保存到本地数据存储中，然后将ACK消息返回给云端。如果cloudhub在此间隔内未收到ACK消息，它将继续重新发送该消息5次。如果所有5次重试均失败，cloudhub将丢弃该事件。</li>
<li>CloudCore中另一个模块SyncController将处理这些失败的事件。即使边缘节点收到该消息，返回的ACK消息也可能在传输过程中丢失。在这种情况下，SyncController将再次发送消息给cloudhub，再次触发下行消息分发，直至成功。<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ns *NodeSession)</span></span>SendMessageWithRetry(copyMsg, msg *beehivemodel.Message)<span class="hljs-type">error</span>&#123;<br>	ackChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>	ns.ackMessageCache.Store(copyMsg.GetID(),ackChan)<br><br>	<span class="hljs-comment">//initialize retry count and timer for sending message</span><br>	retryCount := <span class="hljs-number">0</span><br>	ticker := time.NewTimer(sendRetryInterval)<br><br>	err := ns.connection.WriteMessageAsync(copyMsg)<br>	<span class="hljs-keyword">if</span> err !=<span class="hljs-literal">nil</span>&#123;<br>		<span class="hljs-keyword">return</span> err	<br>	&#125;<br><br>	<span class="hljs-keyword">for</span>&#123;<br>		<span class="hljs-keyword">select</span>&#123;<br>		<span class="hljs-keyword">case</span> &lt;- ackChan:<br>			ns.saveSuccessPoint(msg)<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><br>		<span class="hljs-keyword">case</span> &lt;- ticker.C:<br>			<span class="hljs-keyword">if</span> retryCount == <span class="hljs-number">4</span>&#123;<br>				<span class="hljs-keyword">return</span> ErrwaitTimeout<br>			&#125;<br>			err := ns.connection.WriteMessageAsync(copyMsg)<br>			<span class="hljs-keyword">if</span> err !=<span class="hljs-literal">nil</span>&#123;<br>				<span class="hljs-keyword"><code class="language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ns *NodeSession)</span></span>SendMessageWithRetry(copyMsg, msg *beehivemodel.Message)<span class="hljs-type">error</span>&#123;<br>	ackChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>	ns.ackMessageCache.Store(copyMsg.GetID(),ackChan)<br><br>	<span class="hljs-comment">//initialize retry count and timer for sending message</span><br>	retryCount := <span class="hljs-number">0</span><br>	ticker := time.NewTimer(sendRetryInterval)<br><br>	err := ns.connection.WriteMessageAsync(copyMsg)<br>	<span class="hljs-keyword">if</span> err !=<span class="hljs-literal">nil</span>&#123;<br>		<span class="hljs-keyword">return</span> err	<br>	&#125;<br><br>	<span class="hljs-keyword">for</span>&#123;<br>		<span class="hljs-keyword">select</span>&#123;<br>		<span class="hljs-keyword">case</span> &lt;- ackChan:<br>			ns.saveSuccessPoint(msg)<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><br>		<span class="hljs-keyword">case</span> &lt;- ticker.C:<br>			<span class="hljs-keyword">if</span> retryCount == <span class="hljs-number">4</span>&#123;<br>				<span class="hljs-keyword">return</span> ErrwaitTimeout<br>			&#125;<br>			err := ns.connection.WriteMessageAsync(copyMsg)<br>			<span class="hljs-keyword">if</span> err !=<span class="hljs-literal">nil</span>&#123;<br>				<span class="hljs-keyword">return</span> err<br>			&#125;<br>			retryCount++<br>			ticker.Reset(sendRetryInterval)			<br>		&#125;<br>	&#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/tree/master/cloud/pkg/cloudhub/session">https://github.com/kubeedge/kubeedge/tree/master/cloud/pkg/cloudhub/session</a></li>
</ol>
<h1 id="synccontroller"><a href="#synccontroller" class="headerlink" title="synccontroller"></a>synccontroller</h1><p>在边缘计算场景下，边缘的网络通常是不稳定的，这将导致云边的网络连接频繁断开，在云边协同通信时存在丢失数据的风险。synccontroller是CloudCore中的一个模块，用来保障消息的可靠性发送。在KubeEdge中，使用objectSync对象来持久化云边协同消息状态。在云和边缘状态同步的过程中，云端会实时记录每个边缘节点同步成功的最新消息版本号（ResourceVersion），并以CR的形式持久化保存到K8s中。该机制可以保证在边缘场景下云端故障或者边缘离线重启后消息发送的顺序和连续性，避免重发旧消息引起云边状态不一致问题。与此同时，synccontroller会周期性检查同步云边数据，保持一致性。它主要负责周期性检查每个边缘节点的同步状态，对比K8s中资源的信息，将不一致的状态同步到边缘，确保云边状态的最终一致性。<br>synccontroller在Cloudcore启动时注册，通过beehive消息通信框架调用Start()函数启动synccontroller模块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><code class="language-hljs go">synccontroller.Register(c.Modules.syncController)<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p>synccontroller启动时，会开启周期性的检测，间隔5s执行一次。</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sctl *SyncController)</span></span> Start()&#123;<br>	<span class="hljs-keyword">if</span> !cache.WaitForCacheSync(beehiveContext.Done(),sctl.informersSyncedFuncs...)&#123;<br>		klog.Errorf(<span class="hljs-string">&quot;unable to sync caches for sync controller&quot;</span>)<br>		<span class="hljs-keyword">return</span> <br>	&#125;<br><br>	sctl.deleteObjectSyncs() <span class="hljs-comment">//check outdate sync before start to reconcile</span><br>	<span class="hljs-keyword">go</span> wait.Until(sctl.reconcile, <span class="hljs-number"><code class="language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sctl *SyncController)</span></span> Start()&#123;<br>	<span class="hljs-keyword">if</span> !cache.WaitForCacheSync(beehiveContext.Done(),sctl.informersSyncedFuncs...)&#123;<br>		klog.Errorf(<span class="hljs-string">&quot;unable to sync caches for sync controller&quot;</span>)<br>		<span class="hljs-keyword">return</span> <br>	&#125;<br><br>	sctl.deleteObjectSyncs() <span class="hljs-comment">//check outdate sync before start to reconcile</span><br>	<span class="hljs-keyword">go</span> wait.Until(sctl.reconcile, <span class="hljs-number">5</span>*time.Second,beehiveContext.Done())<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/tree/master/cloud/pkg/synccontroller">https://github.com/kubeedge/kubeedge/tree/master/cloud/pkg/synccontroller</a><br>ObjectSync用于保存命名空间范围的对象。它们的名称由相关的节点名称和对象UUID组成，SyncController将定期比较保存的ObjectSync对象中的已发送resourceVersion与K8s中的对象，然后触发诸如重试或删除之类的事件。当cloudhub将事件添加到NodeMessagePool时，它将与NodeMessagePool中的相应对象进行比较。如果NodeMessagePool中的对象较新，它将直接丢弃这些事件，否则CloudHub将消息发送到边缘侧。<br><img src="/img/kubeedge-7.png"></p>
<h1 id="edgehub"><a href="#edgehub" class="headerlink" title="edgehub"></a>edgehub</h1><p>EdgeHub是一个Web Socket或者Quic协议的客户端，负责与云端CloudCore交互，包括同步云端资源更新、报告边缘主机和设备状态变化到云端等功能。<br>EdgeHub在EdgeCore启动时通过beehive框架注册，并对edgehub进行了初始化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(eh *v1alpha2.EdgeHub,nodeName <span class="hljs-type"><code class="language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(eh *v1alpha2.EdgeHub,nodeName <span class="hljs-type">string</span>)</span></span>&#123;<br>	config.InitConfigure(eh,nodeName)<br>	core.Register(newEdgeHub(eh.Enable))<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p>EdgeHub启动代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(eh *EdgeHub)</span></span>Start()&#123;<br>	eh.certManager = certificate.NewCertManager(config.config.EdgeHub,config.config.NodeName)<br>	eh.certManager.Start()<br>	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> GetCertSyncChannel()&#123;<br>		v &lt;- <span class="hljs-literal">true</span><br>		<span class="hljs-built_in">close</span>(v)<br>	&#125;<br><br>	<span class="hljs-keyword">go</span> eh.ifRotationDone()<br><br>	<span class="hljs-keyword">for</span>&#123;<br>		<span class="hljs-keyword">select</span>&#123;<br>			<span class="hljs-keyword">case</span> &lt;- beehiveContext.Done():<br>			klog.warning(<span class="hljs-string">&quot;EdgeHub stop&quot;</span>)<br>			<span class="hljs-keyword">return</span> <br>		<span class="hljs-keyword">default</span>:<br>		&#125;<br>		err := eh.initial()<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>&#123;<br>			klog.Exitf(<span class="hljs-string">&quot;failed to init controller:%v&quot;</span>,err)<br>			<span class="hljs-keyword">return</span> <br>		&#125;<br>		waitTime := time.Duration(config.Config.Heartbeat)*time.Second*<span class="hljs-number">2</span><br><br>		err = eh.chClient.Init()<br>		<span class="hljs-keyword">if</span> err!= <span class="hljs-literal">nil</span>&#123;<br>			klog.Errorf(<span class="hljs-string">&quot;connection failed: %v,will reconnect after %s&quot;</span>,err,waitTime.String())<br>			time.Sleep(waitTime)<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-comment">//execute hook func after connect</span><br>		eh.pubConnectInfo(<span class="hljs-literal">true</span>)<br>		<span class="hljs-keyword">go</span> eh.routeToEdge()<br>		<span class="hljs-keyword">go</span> eh.routeToCloud()<br>		<span class="hljs-keyword">go</span> eh.keepalive()<br><br>		<span class="hljs-comment">//wait the stop signal</span><br>		<span class="hljs-comment">//stop authinfo manager/websocket connection</span><br>		&lt;-eh.reconnectChan<br>		eh.chClient.UnInit()<br><br>		<span class="hljs-comment">//execute hook function after disconnect</span><br>		eh.pubConnectInfo(<span class="hljs-literal">false</span>)<br><br>		<span class="hljs-comment">//sleep one period of heartbeat, then try to connect cloud hub again </span><br>		klog.warningf(<span class="hljs-string">&quot;connection is broken, will reconnect after %s&quot;</span>,waitTime.String())<br>		time.Sleep(waitTime)<br><br>	<span class="hljs-comment">//clean channel</span><br>	clean:<br>		<span class="hljs-keyword">for</span>&#123;<br>			<span class="hljs-keyword">select</span>&#123;<br>			<span class="hljs-keyword">case</span> &lt;- eh.reconnectChan:<br>			<span class="hljs-keyword">default</span>:<br>				<span class="hljs-keyword"><code class="language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(eh *EdgeHub)</span></span>Start()&#123;<br>	eh.certManager = certificate.NewCertManager(config.config.EdgeHub,config.config.NodeName)<br>	eh.certManager.Start()<br>	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> GetCertSyncChannel()&#123;<br>		v &lt;- <span class="hljs-literal">true</span><br>		<span class="hljs-built_in">close</span>(v)<br>	&#125;<br><br>	<span class="hljs-keyword">go</span> eh.ifRotationDone()<br><br>	<span class="hljs-keyword">for</span>&#123;<br>		<span class="hljs-keyword">select</span>&#123;<br>			<span class="hljs-keyword">case</span> &lt;- beehiveContext.Done():<br>			klog.warning(<span class="hljs-string">&quot;EdgeHub stop&quot;</span>)<br>			<span class="hljs-keyword">return</span> <br>		<span class="hljs-keyword">default</span>:<br>		&#125;<br>		err := eh.initial()<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>&#123;<br>			klog.Exitf(<span class="hljs-string">&quot;failed to init controller:%v&quot;</span>,err)<br>			<span class="hljs-keyword">return</span> <br>		&#125;<br>		waitTime := time.Duration(config.Config.Heartbeat)*time.Second*<span class="hljs-number">2</span><br><br>		err = eh.chClient.Init()<br>		<span class="hljs-keyword">if</span> err!= <span class="hljs-literal">nil</span>&#123;<br>			klog.Errorf(<span class="hljs-string">&quot;connection failed: %v,will reconnect after %s&quot;</span>,err,waitTime.String())<br>			time.Sleep(waitTime)<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-comment">//execute hook func after connect</span><br>		eh.pubConnectInfo(<span class="hljs-literal">true</span>)<br>		<span class="hljs-keyword">go</span> eh.routeToEdge()<br>		<span class="hljs-keyword">go</span> eh.routeToCloud()<br>		<span class="hljs-keyword">go</span> eh.keepalive()<br><br>		<span class="hljs-comment">//wait the stop signal</span><br>		<span class="hljs-comment">//stop authinfo manager/websocket connection</span><br>		&lt;-eh.reconnectChan<br>		eh.chClient.UnInit()<br><br>		<span class="hljs-comment">//execute hook function after disconnect</span><br>		eh.pubConnectInfo(<span class="hljs-literal">false</span>)<br><br>		<span class="hljs-comment">//sleep one period of heartbeat, then try to connect cloud hub again </span><br>		klog.warningf(<span class="hljs-string">&quot;connection is broken, will reconnect after %s&quot;</span>,waitTime.String())<br>		time.Sleep(waitTime)<br><br>	<span class="hljs-comment">//clean channel</span><br>	clean:<br>		<span class="hljs-keyword">for</span>&#123;<br>			<span class="hljs-keyword">select</span>&#123;<br>			<span class="hljs-keyword">case</span> &lt;- eh.reconnectChan:<br>			<span class="hljs-keyword">default</span>:<br>				<span class="hljs-keyword">break</span> clean<br>			&#125;<br>		&#125;	<br>	&#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/kubeedge/kubeedge/blob/master/edge/pkg/edgehub/edgehub.go">https://github.com/kubeedge/kubeedge/blob/master/edge/pkg/edgehub/edgehub.go</a></p>
<p>EdgeHub的启动过程如下所示，主要包含以下步骤：</p>
<ol>
<li>证书初始化，从cloudcore申请证书（若正确配置本地证书，则直接使用本地证书），启动证书轮转模式，然后进入循环</li>
<li>调用eh.initial()创建eh.chClient，接着调用eh.chClient.Init()，初始化过程通过viaduct库建立了websocket&#x2F;quic的connection</li>
<li>调用eh.pubConnectInfo(true)，向edgecore各模块广播已经连接成功的消息</li>
<li>接下来启动了三个协程：<ul>
<li>routeToEdge</li>
<li>routeToCloud</li>
<li>keepalive</li>
</ul>
</li>
</ol>
<p>routeToEdge：接收云端发送下来的消息，如果是同步消息响应，则调用beehive sendResp发送响应，否则，根据消息的group，发送到对应的group</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(eh *EdgeHub)</span></span>routeToEdge()&#123;<br>	<span class="hljs-keyword">for</span>&#123;<br>		<span class="hljs-keyword">select</span>&#123;<br>		<span class="hljs-keyword">case</span>&lt;-beehiveContext.Done():<br>			klog.Warning(<span class="hljs-string">&quot;EdgeHub RouteToEdge stop&quot;</span>)<br>			<span class="hljs-keyword">return</span> <br>		<span class="hljs-keyword">default</span>:<br>		&#125;<br>		message, err := eh.chClient.Receive()<br>		<span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>			klog.Errorf(<span class="hljs-string"><code class="language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(eh *EdgeHub)</span></span>routeToEdge()&#123;<br>	<span class="hljs-keyword">for</span>&#123;<br>		<span class="hljs-keyword">select</span>&#123;<br>		<span class="hljs-keyword">case</span>&lt;-beehiveContext.Done():<br>			klog.Warning(<span class="hljs-string">&quot;EdgeHub RouteToEdge stop&quot;</span>)<br>			<span class="hljs-keyword">return</span> <br>		<span class="hljs-keyword">default</span>:<br>		&#125;<br>		message, err := eh.chClient.Receive()<br>		<span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>			klog.Errorf(<span class="hljs-string">"failed to dispatch message,discard: %v"</span>,err)<br>		&#125;<br>	&#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p>routeToCloud：接收边缘侧其他module发送过来的消息，然后将消息通过websocket&#x2F;quic client发送到云端</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(eh *EdgeHub)</span></span>routeToCloud()&#123;<br>	<span class="hljs-keyword">for</span>&#123;<br>		<span class="hljs-keyword">select</span>&#123;<br>		<span class="hljs-keyword">case</span>&lt;-beehiveContext.Done():<br>			klog.warning(<span class="hljs-string">&quot;EdgeHub RouteToCloud stop&quot;</span>)<br>			<span class="hljs-keyword">return</span> <br>		<span class="hljs-keyword">default</span>:<br>		&#125;<br>		message,err:= beehiveContext.Receive(modules.EdgeHubModuleName)<br>		<span class="hljs-keyword">if</span> err !=<span class="hljs-literal">nil</span>&#123;<br>			klog.Errorf(<span class="hljs-string">&quot;failed to receive message from edge: %v&quot;</span>,err)<br>			time.Sleep(time.Second)<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br><br>		err = eh.tryThrottle(message.GetID())<br>		<span class="hljs-keyword">if</span> err !=<span class="hljs-literal">nil</span>&#123;<br>			klog.Errorf(<span class="hljs-string">&quot;msgID: %s,client rate limiter returned an error: %v&quot;</span>,message.GetID(),err)<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br><br>		<span class="hljs-comment">//post message to cloud hub </span><br>		err = eh.sendToCloud(message)<br>		<span class="hljs-keyword">if</span> err !=<span class="hljs-literal">nil</span>&#123;<br>			klog.Errorf(<span class="hljs-string">&quot;failed to send message to cloud: %v&quot;</span>,err)<br>			eh.reconnectChan &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>			<span class="hljs-keyword"><code class="language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(eh *EdgeHub)</span></span>routeToCloud()&#123;<br>	<span class="hljs-keyword">for</span>&#123;<br>		<span class="hljs-keyword">select</span>&#123;<br>		<span class="hljs-keyword">case</span>&lt;-beehiveContext.Done():<br>			klog.warning(<span class="hljs-string">&quot;EdgeHub RouteToCloud stop&quot;</span>)<br>			<span class="hljs-keyword">return</span> <br>		<span class="hljs-keyword">default</span>:<br>		&#125;<br>		message,err:= beehiveContext.Receive(modules.EdgeHubModuleName)<br>		<span class="hljs-keyword">if</span> err !=<span class="hljs-literal">nil</span>&#123;<br>			klog.Errorf(<span class="hljs-string">&quot;failed to receive message from edge: %v&quot;</span>,err)<br>			time.Sleep(time.Second)<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br><br>		err = eh.tryThrottle(message.GetID())<br>		<span class="hljs-keyword">if</span> err !=<span class="hljs-literal">nil</span>&#123;<br>			klog.Errorf(<span class="hljs-string">&quot;msgID: %s,client rate limiter returned an error: %v&quot;</span>,message.GetID(),err)<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br><br>		<span class="hljs-comment">//post message to cloud hub </span><br>		err = eh.sendToCloud(message)<br>		<span class="hljs-keyword">if</span> err !=<span class="hljs-literal">nil</span>&#123;<br>			klog.Errorf(<span class="hljs-string">&quot;failed to send message to cloud: %v&quot;</span>,err)<br>			eh.reconnectChan &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>			<span class="hljs-keyword">return</span> <br>		&#125;<br>	&#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<p>keepalive：根据心跳周期定期向云端发送心跳信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre class="line-numbers language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(eh *EdgeHub)</span></span>keepalive()&#123;<br>	<span class="hljs-keyword">for</span>&#123;<br>		<span class="hljs-keyword">select</span>&#123;<br>		<span class="hljs-keyword">case</span> &lt;-beehiveContext.Done():<br>			klog.warning(<span class="hljs-string">&quot;EdgeHub KeepAlive stop&quot;</span>)<br>			<span class="hljs-keyword">return</span> <br>		<span class="hljs-keyword">default</span>:<br>		&#125;<br>		msg := model.NewMessage(<span class="hljs-string">&quot;&quot;</span>).<br>			BuildRouter(modules.EdgeHubModuleName,<span class="hljs-string">&quot;resource&quot;</span>,<span class="hljs-string">&quot;node&quot;</span>,messagepkg.OperationKeepalive)<br>			FillBody(<span class="hljs-string">&quot;ping&quot;</span>)<br><br>		<span class="hljs-comment">//post message to cloud hub</span><br>		err := eh.sendToCloud(*msg)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>&#123;<br>			klog.Errorf(<span class="hljs-string">&quot;websocket write error: %v&quot;</span>,err)<br>			eh.reconnectChan &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>			<span class="hljs-keyword"><code class="language-hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(eh *EdgeHub)</span></span>keepalive()&#123;<br>	<span class="hljs-keyword">for</span>&#123;<br>		<span class="hljs-keyword">select</span>&#123;<br>		<span class="hljs-keyword">case</span> &lt;-beehiveContext.Done():<br>			klog.warning(<span class="hljs-string">&quot;EdgeHub KeepAlive stop&quot;</span>)<br>			<span class="hljs-keyword">return</span> <br>		<span class="hljs-keyword">default</span>:<br>		&#125;<br>		msg := model.NewMessage(<span class="hljs-string">&quot;&quot;</span>).<br>			BuildRouter(modules.EdgeHubModuleName,<span class="hljs-string">&quot;resource&quot;</span>,<span class="hljs-string">&quot;node&quot;</span>,messagepkg.OperationKeepalive)<br>			FillBody(<span class="hljs-string">&quot;ping&quot;</span>)<br><br>		<span class="hljs-comment">//post message to cloud hub</span><br>		err := eh.sendToCloud(*msg)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>&#123;<br>			klog.Errorf(<span class="hljs-string">&quot;websocket write error: %v&quot;</span>,err)<br>			eh.reconnectChan &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>			<span class="hljs-keyword">return</span> <br>		&#125;<br>		time.Sleep(time.Duration(config.Config.Heartbeat)*time.Second)<br>	&#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>
<ol start="5">
<li>当云边消息传送过程中出现错误时，边缘部分会重新init相应的websocket&#x2F;quic client，与云端重新建立连接。</li>
</ol>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://shemol.tech/2024/03/13/KubeEdge云边通信框架/%20Shemol's Blog%20KubeEdge云边通信框架"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2024/04/16/A%20Multipath%20Extension%20to%20the%20QUIC%20Module%20for%20ns-3/" title="A Multipath Extension to the QUIC Module for ns-3"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: A Multipath Extension to the QUIC Module for ns-3</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2024/02/05/2024%E5%B9%B4%E7%AC%AC5%E5%91%A8%E5%91%A8%E6%8A%A5/" title="2024年第5周周报">Next post: 2024年第5周周报&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="https://shemol.tech" rel="noopener noreferrer">Shemol</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>